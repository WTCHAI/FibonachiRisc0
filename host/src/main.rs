// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use fibonachi_methods::{
    FINALIZE_FIBONACHI_ID,FINALIZE_FIBONACHI_ELF 
};

use risc0_zkvm::{default_prover, ExecutorEnv, ProveInfo};

use rand::rngs::OsRng;  // Cryptographically secure RNG from the OS
use rand::Rng;  // Trait to generate random numbers

// Declare struct payload & serde used for derive struct in rust guess ? 
use serde::Serialize;
#[derive(Serialize)] 
struct Payload{
    times : u32,
    x : u64, 
    y : u64,
    correct_y : u64,
    binding_randomness : u64,
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    // donno this 
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // This is private input knowing only real prover 
    let private_inputy = 10 ; 

    // randomness setup
    let mut rng = OsRng ;
    let mut binding_randomness_values = rng.gen() ; 
    
    while binding_randomness_values < private_inputy || binding_randomness_values == 0 {
        println!("Genreating random but got {} rerandom ",binding_randomness_values) ; 
        binding_randomness_values = rng.gen() ;
    }

    // Define variable for our program
    let payload= Payload { 
        times : 15 , 
        x : 0, 
        y : 10,         // Testing random input y to generate proof
        correct_y : private_inputy,
        binding_randomness : binding_randomness_values,
    }; 
    
    // Creating env as environtment for our program 
    let env = ExecutorEnv::builder().write(&payload).unwrap().build().unwrap() ; 
    
    // Init prove and guest computation 
    let prover = default_prover() ; 
    
    // Getting prove object with specific env and ELF more understand in docs
    // Executable and Linkable Format refers to compiles WebAssembly (WASM) for guest program 
    // unwrap () is method in rust when the things that we wanted to use is stayed in some process 
    // let result = sum(x,y) : result.unwrap() : to get result.
    let proof_infomation: ProveInfo = prover.prove(env, FINALIZE_FIBONACHI_ELF).unwrap() ; 
    
    // Receipt is a Proof that guest code computation inside vm known as Proof : ChatGPT
    let receipt: risc0_zkvm::Receipt = proof_infomation.receipt ; 
    
    // Host used env::commit() to write the result from computation so 
    // Journal is part of receipt & records data that guest want to communicated to host 
    // or we can say it's result from computation 
    // So we gona decode the result from computation 
    let result : u64 = receipt.journal.decode().unwrap() ; 
    println!("Result from fibonachi nunmber when having input x and y compute 15 times : {}",result) ; 
    
    // After getting public input as result we can verify the proof 
    // Creating proof from receipt 
    // This process receipt is proof but this below verify 
    // Is just verify the guesttID match to the guest program
    receipt.verify(FINALIZE_FIBONACHI_ID).unwrap() ; 

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    // If the process of generate proof and verifing is correctly we will see below message
    println!("Receipt verification succeeded! Computation was done correctly.");
}
