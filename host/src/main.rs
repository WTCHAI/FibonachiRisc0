// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    FIBONACCI_GUEST_ELF, FIBONACCI_GUEST_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv, ProveInfo};
// Declare struct payload & serde used for derive struct in rust guess ? 
use serde::Serialize;
#[derive(Serialize)] 
struct Payload{
    times : u32,
    x : u64, 
    y : u64 
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    // donno this 
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // Define variable for our program
    let payload= Payload { 
        times : 15 , 
        x : 0,
        y : 1,
    }; 

    // Creating env as environtment for our program 
    let env = ExecutorEnv::builder().write(&payload).unwrap().build().unwrap() ; 
    
    // Init prove and guest computation 
    let prover = default_prover() ; 
    
    // Getting prove object with specific env and ELF more understand in docs
    // Executable and Linkable Format refers to compiles WebAssembly (WASM) for guest program 
    // unwrap () is method in rust when the things that we wanted to use is stayed in some process 
    // let result = sum(x,y) : result.unwrap() : to get result. 
    let proof_infomation: ProveInfo = prover.prove(env, FIBONACCI_GUEST_ELF).unwrap() ; 
    
    // Receipt is a Proof that guest code computation inside vm known as Proof : ChatGPT
    let receipt = proof_infomation.receipt ; 
    
    // Host used env::commit() to write the result from computation so 
    // Journal is part of receipt & records data that guest want to communicated to host 
    // or we can say it's result from computation 
    // So we gona decode the result from computation 
    let result : u64 = receipt.journal.decode().unwrap() ; 
    println!("Result from fibonachi nunmber when having input x and y compute 15 times : {}",result) ; 
    
    // After getting public input as result we can verify the proof 
    // Creating proof from receipt 
    // This process receipt is proof but this below verify 
    // Is just verify the guesttID match to the guest program 
    receipt.verify(FIBONACCI_GUEST_ID).unwrap() ; 

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    // If the process of generate proof and verifing is correctly we will see below message
    println!("Receipt verification succeeded! Computation was done correctly.");
}
